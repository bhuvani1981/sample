name: build-ars-web

# Controls when the action will run.
on:
  push:
    branches-ignore:
      - 'gh_pages'
    tags-ignore:
      - '*.*' # We don't want this to run on release
    paths-ignore:
      - '**.md'
  pull_request:
    # The branches below must be a subset of the branches above
    branches: [ develop,'Release-*' ]
    paths-ignore:
      - '**.md'
  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:
    inputs:
      scope:
        type: choice
        description: What type of release
        required: true
        default: "patch"
        options:
          - major
          - minor
          - patch
permissions:
  id-token: write
  contents: write
  actions: write
env:
  APP_PROJ_NAME: 'ars-web'
  scope: "${{ github.event.inputs.scope }}"

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  build:
    name: build
    runs-on: ubuntu-latest
    timeout-minutes: 15
    strategy:
      matrix:
        include:
          - node-version: 20.x
            experimental: false
    continue-on-error: ${{ matrix.experimental }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set Branch
        id: get_branch
        run: |
          if ${{ github.event_name == 'pull_request' }}
          then
            echo "BRANCH_NAME=${GITHUB_HEAD_REF}" >> $GITHUB_ENV
          else
            echo "BRANCH_NAME=${GITHUB_REF##*/}" >> $GITHUB_ENV
          fi
          echo "COMMIT_ID=$(echo ${GITHUB_SHA} | cut -c1-7)" >> $GITHUB_ENV
          echo "BUILD_ID=$(echo ${GITHUB_RUN_NUMBER})" >> $GITHUB_ENV
          # Fetch all tags and sort them using version numer
          # Extract only the version portion and remove any trailing text
          git fetch --tags
          echo "latest_release_tag=$(git tag -l | sort -V | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+' | tail -n1 | sed -E 's/^v//; s/[^0-9.].*$//')" >> $GITHUB_ENV
          echo "TIMESTAMP=$(date "+%s")" >> ${GITHUB_ENV}

      - name: Output Variables
        run: |
          echo GitHub REF is ${GITHUB_REF}
          echo branch name is $BRANCH_NAME
          echo commit ID is $COMMIT_ID
          echo TimeStamp is $TIMESTAMP
          echo latest_release_tag is $latest_release_tag
          echo BUILD_ID is $BUILD_ID

      - name: Setup Node ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}

      - name: Set Environment variable to get next release version
        run: |
          scope=${scope:-patch}
          echo "scope: ${scope}"
          if [ "$scope" == "major" ]; then
            IFS='.' read -ra version_parts <<< "${{env.latest_release_tag}}"
            major_version="${version_parts[0]}"
            next_version="$((major_version +1)).0.0" >> $GITHUB_ENV
          elif [ "$scope" == "minor" ]; then
            IFS='.' read -ra version_parts <<< "${{env.latest_release_tag}}"
            major_version="${version_parts[0]}"
            minor_version="${version_parts[1]}"
            next_version="$major_version.$((minor_version +1)).0" >> $GITHUB_ENV
          else
            IFS='.' read -ra version_parts <<< "${{env.latest_release_tag}}"
            major_version="${version_parts[0]}"
            minor_version="${version_parts[1]}"
            patch_version="${version_parts[2]}"
            next_version="$major_version.$minor_version.$((patch_version +1))"
          fi
          echo "next_release_version=$next_version" >> $GITHUB_ENV

      - name: Set Release version variable and Retag packageVersion for branch
        run: |
          echo "RELEASE_VERSION=${{env.APP_PROJ_NAME}}-${{env.next_release_version}}-${{env.COMMIT_ID}}-${{env.BUILD_ID}}.tar.gz" >> $GITHUB_ENV
          if [[ "$BRANCH_NAME" != "master" && "$BRANCH_NAME" != "develop" ]]; then
            echo "RELEASE_VERSION=${{env.APP_PROJ_NAME}}-${{env.next_release_version}}-${{env.COMMIT_ID}}-${{env.BUILD_ID}}-${{env.BRANCH_NAME}}.tar.gz" >> $GITHUB_ENV
          fi

      - name: create metadata
        run: |
          current_date=$(date +%y%m%d_%H%M%S)
          echo "appName=$APP_PROJ_NAME" >> $GITHUB_ENV
          echo "distributionFileName=$RELEASE_VERSION" >> $GITHUB_ENV
          echo "lastBuildDate=$current_date"  >> $GITHUB_ENV
          echo "version=${{env.APP_PROJ_NAME}}-${{env.next_release_version}}-${{env.COMMIT_ID}}-${{env.BUILD_ID}}" >> $GITHUB_ENV

      # this is a hack until they fix the frontend to read the environment.json file
      - name: Update index.html, version.ts
        run: |
          sed -i "2 i\<meta name=\"distributionFileName\" content=\"${{env.RELEASE_VERSION}}\"\>" ./src/index.html
          sed -i "2 i\<meta name=\"lastBuildDate\" content=\"${{env.lastBuildDate}}\"\>" ./src/index.html
          sed -i "2 i\<meta name=\"version\" content=\"${{env.version}}\"\>" ./src/index.html
          touch src/version.ts
          echo "export const version = { version: '${{env.version}}' };" > src/version.ts
          cat src/version.ts

      - name: Run npm clean
        run: npm cache clean --force

      - name: Run npm install
        run: npm install

      - name: Run npm build
        run: npm run cibuild

      - name: Run npm test with coverage
        run: npm run test-cc

      - name: Show coverage directory
        run: find . -type d -name coverage -exec echo {} \; -exec ls -al {} \;
        if: always()

      - name: Prepare Package
        run: |
          tar czf ${{ env.RELEASE_VERSION }} -C ${{ github.workspace }}/dist/ .

      - name: Upload the Package
        uses: actions/upload-artifact@v4
        with:
          name: ${{ env.RELEASE_VERSION }}_NODE${{ matrix.node-version }}
          path: ${{ github.workspace }}/${{ env.RELEASE_VERSION }}

